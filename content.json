{"meta":{"title":"Devbird's blog","subtitle":null,"description":null,"author":"devbird","url":"http://tiandawu.github.io"},"pages":[{"title":"Categories","date":"2016-07-11T02:20:38.336Z","updated":"2016-07-11T02:20:38.336Z","comments":true,"path":"categories/index.html","permalink":"http://tiandawu.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-07-11T02:20:38.336Z","updated":"2016-07-11T02:20:38.336Z","comments":true,"path":"tags/index.html","permalink":"http://tiandawu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"sql笔记","slug":"sql笔记","date":"2016-07-12T04:50:42.000Z","updated":"2016-07-12T05:07:20.078Z","comments":true,"path":"2016/07/12/sql笔记/","link":"","permalink":"http://tiandawu.github.io/2016/07/12/sql笔记/","excerpt":"sql语句是数据库很重要的一部分，这篇文章主要记录了一些基本的sql语法，包括对数据库的操作、对表的增删改查、以及数据约束和多表查询等。","text":"sql语句是数据库很重要的一部分，这篇文章主要记录了一些基本的sql语法，包括对数据库的操作、对表的增删改查、以及数据约束和多表查询等。 一、数据库管理 查询所有数据库 show databases; 创建数据库 create database test; 查看数据库的默认字符集show create database test; 删除数据库drop database test; 修改数据库默认字符集alter database test default character set utf8; 二、表管理 查看所有表 show tables; 创建表 create table student(id int,name varchar(20),age int); 查看表结构 desc student; 删除表 drop table student; 修改表 添加字段 alter table student add column gender varchar(10); 删除字段 alter table student drop column gender; 修改字段类型 alter table student modify column age varchar(10); 修改字段名称 alter table student change column name sname varchar(20); 修改表名称 alter table student rename to teacher; 增删改数据 增加数据 插入所有字段 insert into student values(1,&#39;devbird&#39;,10); 插入部分字段 insert into student(id,name) values(2,&#39;dawu&#39;) 修改数据 update student set age=20,gender=&#39;男&#39; where id=1; 删除数据 带条件的删除 delete from student where id=2; 删除所有数据 方式一：delete from student; 方式二：truncate table student; 两种方式区别： delete from: ①可以带条件删除；②只能删除表的数据，不能删除表的约束；③使用delete from删除的数据可以回滚（事务）。 truncate table:①不能带条件删除；②既可以删除表的数据，也可以删除表的约束；③使用truncate table删除的数据不能回滚（事务）。 查询数据 查询所有列 select * from student; 查询指定列 select id,name from student; 查询时添加常量列class select id,name,&#39;class&#39; from student; 查询时合并列 select id name,(math+english) as &#39;总成绩&#39; from student; 查询时去除重复记录 select distinct gender from student; 条件查询 逻辑条件： and(与) or(或) select * from student where id=1 and name=&#39;devbird&#39;; select * from student where id=1 or name=&#39;devbird&#39;; 比较条件：&gt;, &lt;, &gt;=, &lt;=, =, &lt;&gt;(不等于), between A and B(等价于&gt;=A 且&lt;=B) select * from student where math&gt;60; select * from student where math&gt;=60 and math&lt;=90; select * from student where math between 60 and 90; select * from student where age&lt;&gt;20; 判空条件：is null, is not null, =’’, &lt;&gt;’’ select * from student where address is null; select * from student where address=&#39;&#39;; 模糊条件：like %:表示任意个字符； _：表示一个字符； 查询姓李的学生：select * from student where name like &#39;李%&#39;; 查询姓李且名字只有两个字的学生：select * from student where name like &#39;李_&#39;; 聚合查询 -常用的聚合函数：sum(), max(), min(), avg(), count() 查询学生math的总成绩：select sum(math) as &#39;数学总成绩&#39; from student; 查询math最高分：select max(math) as &#39;最高分&#39; from student; 查询math最低分：select min(math) as &#39;最低分&#39; from student; 查询math平均分：select avg(math) as &#39;数学平均分&#39; from student; 统计有多少学生：select count(*) from student; 分页查询 分页： limit 其实行，查询几行 分页查询当前页数据的sql：select * from student limit (当前页-1)*每页显示多少条，每页显示多少条; 查询排序 语法：order by 字段 asc/desc (asc:升序；desc:降序) select * from student order by math asc; select * from student order by math desc; 分组查询 按性别分组：select * from student group by gender; 统计每组的人数：select gender,count(*) from student group by gender; 分组查询后筛选 -查询总人数大于二的性别：select gender,count(*) from student group by gender having count(*)&gt;2; 三、数据约束 默认值 create table student(id int,name varchar(20),address varchar(30) default &#39;重庆&#39;); 非空 create table student(id int,name varchar(20),gender varchar(10) not null); 唯一 create table student(id int unique,name varchar(20)); 主键 create table student(id int primary key,name varchar(20)); 自增长 create table student(id int primary key auto_increment,name varchar(20)); 外键 主表：create table dept(id int primary key,deptName varchar(20)); 副表：create table employee(id int primary key,empName varchar(20),deptId int,constraint employee_dept_fk foreign key(deptId) references dept(id)); 当有了外键约束，添加数据的顺序： 先添加主表，再添加副表数据。 当有了外键约束，修改数据的顺序： 先修改副表，再修改主表数据。 当有了外键约束，删除数据的顺序： 先删除副表，再删除主表数据。 级联操作 级联修改： ON UPDATE CASCADE 级联删除： ON DELETE CASCADE 主表：create table dept(id int primary key,deptName varchar(20)); 副表：create table employee(id int primary key,empName varchar(20),deptId int,constraint employee_dept_fk foreign key(deptId) references dept(id) on update cascade on delete cascade); 四、多表查询 内连接查询 方式一：select empName,deptName from employee,dept where employee.deptId=dept.id; 方式二：select empName,deptName from employee inner join dept on employee.deptId=dept.id; 使用别名：SELECT e.empName,d.deptName FROM employee e INNER JOIN dept d ON e.deptId=d.id; 左[外]连接查询 SELECT d.deptName,e.empName FROM dept d LEFT OUTER JOIN employee e ON d.id=e.deptId; 用左边表的数据去匹配右边表的数据，如果符合连接条件的结果则显示，如果不符合连接条件则显示null,左外连接：左表的数据一定会完成显示! 右[外]连接查询 SELECT d.deptName,e.empName FROM employee e FROM employee e RIGHT OUTER JOIN dept d ON d.id=e.deptId; 使用右边表的数据去匹配左边表的数据，如果符合连接条件的结果则显示，如果不符合连接条件则显示null,右外连接：右表的数据一定会完成显示！ 自连接查询 SELECT e.empName,b.empName FROM employee e LEFT OUTER JOIN employee b ON e.bossId=b.id;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://tiandawu.github.io/categories/笔记/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tiandawu.github.io/tags/学习笔记/"}]},{"title":"Android中实现自定义XMPP消息包收发","slug":"Android中实现自定义XMPP消息包收发","date":"2016-06-05T01:46:14.000Z","updated":"2016-07-12T05:12:27.031Z","comments":true,"path":"2016/06/05/Android中实现自定义XMPP消息包收发/","link":"","permalink":"http://tiandawu.github.io/2016/06/05/Android中实现自定义XMPP消息包收发/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Android平台实现XMPP即时通讯主要是使用asmack这个包，asmack是XMPP协议的实现。但是asmack只能帮助我们实现一些基本消息包的收发，如果需要实现特定的自定义消息包收发需要我们自己处理。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Android平台实现XMPP即时通讯主要是使用asmack这个包，asmack是XMPP协议的实现。但是asmack只能帮助我们实现一些基本消息包的收发，如果需要实现特定的自定义消息包收发需要我们自己处理。 一、asmack消息的发送和接收 发送Message消息： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发送一个message结的消息，可以使用sendMessage()发送消息，这个方法有两个重载方法，一种类型的参数是String类型，另一种则是传入Message对象。String类型的方法传入的字符串即为要发送的消息；传入message对象的方需要写一个类继承Message，重写toXML()方法，toXML()方法的返回值即为要发送的消息。例如：123456789101112131415161718192021222324252627282930313233//1、通过传入String类型的sendMessage()方法发送消息：ChatManager chatManager = xmppConnection.getChatManager(); /** * String userJID 对方的JID * MessageListener listener 消息监听，当收到消息后会回调processMessage(Chat chat, Message message)方法 */Chat mChat = chatManager.createChat(mToUser, this);mChat.sendMessage(\"your content\");//2、通过传入Message对象的sendMessage()方法发送消息：/***写一个类继承Message重写toXML()方法，方法的返回值即为要发送的消息*/public class MyMessage extends Message &#123; @Override public String toXML() &#123; return \"your content\"; &#125;&#125;ChatManager chatManager = xmppConnection.getChatManager(); /** * String userJID 对方的JID * MessageListener listener 消息监听，当收到消息后会回调processMessage(Chat chat, Message message)方法 */Chat mChat = chatManager.createChat(mToUser, this);MyMessage myMessage = new MyMessage();mChat.sendMessage(myMessage); 接收Message消息： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接收Message类型的消息主要是在processMessage(Chat chat, Message message)方法中，当收到消息后都会回调这个方法，需要实现MessageListener这个接口，然后实现接口中的processMessage(Chat chat, Message message)方法。 二、发送和接收自定义类型的IQ结消息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当发送的iq消息中包含自定义的xml结的时候，asmack提供的解析并不能识别这些自定义的xml结，所以就需要我们自己实现消息包的解析和拼装。 1、发送含自定义xml结的iq消息：例如发送这样一个iq消息：&lt;iq id=&#39;123&#39; type=&#39;get&#39; from=&#39;client@xmpp/B&#39; to=&#39;client2@xmpp/s2&#39;&gt;&lt;req var=&#39;read&#39;&gt;&lt;attr var=&#39;temprature&#39;/&gt;&lt;/req&gt;&lt;/iq&gt; 1234567891011121314151617//步骤：//1、写一个类继承IQ并重写getChildElementXML()方法，该方法的返回值将作为消息体。public class MyIQ extends IQ &#123; @Override public String getChildElementXML() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"&amp;lt;req var='read'&amp;gt;&amp;lt; attr var='temprature'/&amp;gt;&amp;lt;/req&amp;gt;\"); return stringBuilder.toString(); &#125;&#125;//2、发送这个含自定义xml结的iq消息包MyIQ packet = new MyIQ();packet.setType(IQ.Type.GET);//设置IQ结type packet.setFrom(\"client@xmpp/B\");//设置IQ结from packet.setTo(\"client2@xmpp/s2\");//设置IQ结to xmppConnection.sendPacket(packet);//发送消息包 2、解析服务器返回的iq消息包，消息包中含自定义xml结：例如解析服务器返回的这样一个iq消息：&lt;iq id=&#39;12&#39; type=&#39;result&#39; from=&#39;client2@xmpp/s2&#39; to=&#39;client@xmpp/B&#39;&gt;&lt;resp xmlns=&#39;data&#39;&gt;&lt;attr var=&#39;temprature&#39;&gt;17&lt;/attr&gt;&lt;/resp&gt;&lt;/iq&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//步骤：//1、写一个类 implements PacketListener接口并实现其中的processPacket(Packet packet)方法。public class MyPacketListener implements PacketListener &#123; @Override public void processPacket(Packet packet) &#123; //当收到消息包就会回调该方法 &#125;&#125;//2、添加包监听器MyPacketListener mMyPacketListener = new MyPacketListener();//该方法有两个参数//第一个参数： PacketListener 包监听器//第二个参数： PacketFilter 包过滤器xmppConnection.addPacketListener(mMyPacketListener, null);//完成以上两步后，当收到消息包都会回调MyPacketListener中的processPacket(Packet packet)方法。//3、写一个类继承IQ并实现getChildElementXML()方法。public class GetDataResp extends IQ &#123; //例如我们要获取上面iq消息包中的temprature和17两个属性,所以将这两个值声明为成员变量,并生成get和set方法。 public String var; public String value; public String getVar() &#123;return var;&#125; public void setVar(String var) &#123;this.var = var;&#125; public String getValue() &#123;return value;&#125; public void setValue(String value) &#123;his.value = value;&#125; @Override public String getChildElementXML()&#123; //拼装消息 StringBuilder buf = new StringBuilder(); buf.append(\"&amp;lt;resp xmlns='get:data'&amp;gt;&amp;lt;attr var='\");· buf.append(getVar()); buf.append(\"'&gt;\"); buf.append(getValue()); buf.append(\"&amp;lt;/attr&amp;gt;&amp;lt;/resp&amp;gt;\"); return buf.toString(); &#125;&#125;//4、写一个类implements IQProvider并实现接口中的parseIQ(XmlPullParser parser)方法。public class GetDataRespProvider implements IQProvider &#123; @Override public IQ parseIQ(XmlPullParser parser) throws Exception &#123; GetDataResp getDataResp = new GetDataResp();//这个对象是上面第三步中的那个类对象 boolean done = false; while (!done) &#123; int eventType = parser.next(); if (eventType == XmlPullParser.START_TAG) &#123; if (parser.getName().equals(\"attr\")) &#123; String var = parser.getAttributeValue(\"\", \"var\");//获取var属性的value即：temprature String value = parser.nextText();//获取attr的文本即：17 getDataResp.setVar(var); getDataResp.setValue(value); &#125; &#125;else if (eventType == XmlPullParser.END_TAG) &#123; if (parser.getName().equals(\"resp\")) &#123; done = true; &#125; &#125; &#125; return getDataResp; &#125;&#125;//5、在配置ConnectionConfiguration时添加IQProvider//第一个参数是：String 元素的名称//第二个参数是：String 命名空间//第三个参数是：Object 需要传入一个prvider对象ProviderManager.getInstance().addIQProvider(\"resp\", \"data\", new GetDataRespProvider());//6、在第一步MyPacketListener中的processPacket(Packet packet)方法中获取相应消息包public class MyPacketListener implements PacketListener &#123; @Override public void processPacket(Packet packet) &#123; if (packet instanceof GetDataResp) &#123; GetDataResp getDataResp = (GetDataResp) packet; String from = getDataResp.getFrom(); String to = getDataResp.getTo(); String var = getDataResp.getVar(); String value = getDataResp.getValue(); &#125; &#125;&#125; 三、总结 发送message类型的消息中如果带有自定义xml结,需要写一个类继承Message并重写toXML()方法，该方法的返回值便是消息体。 发送的iq类型的消息中如果带有自定义xml结，需要写一个类继承IQ并重写getChildElementXML()方法，该方法的返回值将作为消息体 服务器返回的iq消息类型中如果带有自定义的xml结： 写一个类继承IQ并重写getChildElementXML()方法，将服务器返回的消息中需要的信息做成成员变量，并拼装出消息体，最后作为返回值返回。 写一个类implements IQProvider并实现接口中的parseIQ(XmlPullParser parser)方法，然后在该方法中做出对应的解析过程，最后通过返回值返回上一个步骤中的IQ对象。 服务器返回的iq消息中的消息体必须带有命名空间。 需要通过这个方法ProviderManager.getInstance().addIQProvider(&quot;resp&quot;, &quot;data&quot;, new GetDataRespProvider());添加相应的IQProvider。 如果需还需要实现一些自定义的解析，可以修改asmack源码中的PacketParserUtils这个类中对应的方法。 下面是源码地址：点击：下载地址","categories":[{"name":"Android","slug":"Android","permalink":"http://tiandawu.github.io/categories/Android/"}],"tags":[{"name":"XMPP","slug":"XMPP","permalink":"http://tiandawu.github.io/tags/XMPP/"}]},{"title":"正则表达式学习笔记","slug":"正则表达式学习笔记","date":"2016-02-27T06:40:35.000Z","updated":"2016-07-12T04:51:36.970Z","comments":true,"path":"2016/02/27/正则表达式学习笔记/","link":"","permalink":"http://tiandawu.github.io/2016/02/27/正则表达式学习笔记/","excerpt":"这篇文章主要记录了正则表达式的一些基本语法、修正模式和php常用的正则表达式函数！","text":"这篇文章主要记录了正则表达式的一些基本语法、修正模式和php常用的正则表达式函数！ 一、正则表达式基本语法： 界定符 原子 元字符 量词 边界控制 模式单元 1. 界定符 表示一个正则表达式的开始和结束。（如：/[0-9]/或#[0-9]#或{[0-9]}） 一般使用/或#作为界定符，不建议用{} 2. 原子 （1）可见原子：Unicode编码表中用键盘输出后肉眼可见的字符 如：标点；\"_?.等，英文字母数字a-z A-Z 0-9,其他可见字符等 （2）不可见原子：Unicode编码表中用键盘输出后肉眼不可见的字符 如：换行符\\n,回车\\r,制表符\\t，空格,其他不可见符号 3. 元字符 （1）原子的筛选方式： | 匹配两个或者多个分支选择; [] 匹配方括号中的任意一个原子; [^] 匹配除方括号中的原子之外的任意字符; （2）原子的集合： . 匹配除换行符之外的任意字符,即[^\\n]; \\d 匹配任意一个十进制数字，即[0-9]; \\D 匹配任意一个非十进制数字，即[^0-9]; \\s 匹配一个不可见原子，即[\\f\\n\\r\\t\\v]; \\S 匹配一个可见原子，即[^\\f\\n\\r\\t\\v]; \\w 匹配任意一个数字、字母或下划线，即[0-9a-zA-Z_]; \\W 匹配任意一个非数字、字母或下划线，即[^0-9a-zA-Z_]; 4. 量词 {n} 表示其前面的原子恰好出现n次; {n,} 表示其前面的原子最少出现n次; {n,m} 表示其前面的原子最少出现n次，最多出现m次; * 匹配0次、1次或者多次其之前的原子，即{0,}; + 匹配1次或者多次其之前的原子，即{1,}; ? 匹配0次或者1次其之前的原子，即{0,1}; 5. 边界控制 ^ 匹配字符串开始的位置; $ 匹配字符串结尾的位置; 6. 模式单元 () 匹配其中的整体为一个原子; 二、模式修正：1.懒惰匹配与贪婪匹配 (1) 贪婪匹配：匹配结果存在歧义时取其长(默认为贪婪模式) (2) 懒惰匹配：匹配结果存在歧义时取其短（懒惰模式标识：U 即：只需要在正则表达式的末尾加上U 如：/so.+234/U） 2.常见修正模式 U 懒惰匹配; i 忽略英文字母大小写; x 忽略空白; s 让元字符'.'匹配包括换行符在内的所有字符; e 配合函数preg_replace()使用,可以把匹配来的字符串当作正则表达式执行; 三、PHP中常用的正则表达式函数：1. preg_match()与preg_match_all() preg_match($pattern,$subject,[array &matches]) 第三个参数是传递引用，参数可选； preg_match()只会在$subject中匹配一次； return 匹配的次数（0次或1次） preg_match_all($pattern,$subject,array &matches) 第三个参数是传递引用，参数必填； preg_match_all()会把$subject中所有符合的匹配出来； return 匹配的次数（0次或多次） 2. preg_replace()与preg_filter() preg_replace($pattern,$replacement,$subject) return 返回被替换后的结果，（当为数组集时：不管替换部分和没有替换部分都会返回）； preg_filter($pattern,$replacement,$subject) return 返回替换后的结果，（当为数组集时：只保留被替换过的，没有替换的部分不返回；） 3. preg_grep() preg_grep($pattern,array $input) return 只返回被匹配到的结果集，没有匹配到的就过滤掉不返回 4. preg_split() preg_split($pattern,$subject) return 用匹配到的结果去截取字符串，将截取后的结果返回； 5. preg_quote() preg_quote($str) 正则运算符转义，如： ．＼＋＊？［＾］＄（）｛｝＝！＜＞｜：－","categories":[{"name":"笔记","slug":"笔记","permalink":"http://tiandawu.github.io/categories/笔记/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tiandawu.github.io/tags/学习笔记/"}]},{"title":"怎么解决Android studio导入项目卡死","slug":"Android studio常见错误","date":"2016-01-16T09:29:24.000Z","updated":"2016-07-11T04:26:05.065Z","comments":true,"path":"2016/01/16/Android studio常见错误/","link":"","permalink":"http://tiandawu.github.io/2016/01/16/Android studio常见错误/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用Android studio的时候常常遇到这样的问题，从github或是其他地方导入项目，Android studio呈现卡死的现象！当遇到这种情况时，可以看看是下面那种情况，在按照方法来解决！","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用Android studio的时候常常遇到这样的问题，从github或是其他地方导入项目，Android studio呈现卡死的现象！当遇到这种情况时，可以看看是下面那种情况，在按照方法来解决！ 一、首次启动studio卡死当我们安装完studio，首次启动时如果卡死在这个画面： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时，我们只要到android studio的安装目录的bin目录下去找这个文件：idea.properties 文件，在文件的最后追加这样一句话即可：disable.android.first.run=true另一种方法时翻墙让它自己去慢慢下载！ 二、导入其他地方的项目卡死（很慢）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从github或其他地方导入项目如果studio很久也是像卡死的状态，这时你可以先将进程杀死，沿着这个路径：项目/gradle/wrapper找到这个文件： gradle-wrapper.properties ，将它打开看看这里： 一种方法是，去这个网站（Gradle Distributions）下好对应的版本。或者去gradle官网（需要翻墙，下载还很慢）下载也可以！然后将下载好的这个文件（gradle-2.10-all.zip）拷贝到这个目录下： C:\\Users\\Administrator\\.gradle\\wrapper\\dists \\gradle-2.10-all\\a4w5fzrkeut1ox71xslb49gst 注：a4w5fzrkeut1ox71xslb49gst这个文件夹名是随机数所以很可能不是一样的，然后再导入项目！ 另一种方法是，将上面那个文件的版本改成你自己那个目录有的版本，然后再导入项目。 三、studio升级后，新建项目卡死&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天在将studio 升级到最新版本后，新建了个醒目结果一直卡在这个界面： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我发现它又是去给我下载：gradle-2.10-all.zip去了，于是我按照上面的第二种方法修改了gradle的版本，然后再导入编译，结果又出现下面的问题： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后我就知道是gradle的版本高了，于是就到：项目的根目录找到build.gradle这个文件，做如下图的修改： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改后我又编译了一次，结果又冒出这样一个错误，如图： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是我又找到我又打开app目录下的build.gradle打开发现:compileSdkVersion &#39;Google Apis:Google Apis:23&#39;,最后将他做了如下图的修改： 这样项目才算是编译通过，能部署到手机上！ 最后我又按照上面的前一种方法做了一遍，发现一次性解决问题，什么文件也不用修改！ 四、最后总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不管是导入项目还是新建项目卡死，发现它是去下载：gradle-xxx-all.zip的时候最好的解决方案就是按照上面的方法自己去下载对应的版本，然后放到那个目录下，这样做省去了修改这，修改那的麻烦！","categories":[],"tags":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://tiandawu.github.io/tags/踩过的坑/"}]},{"title":"QQ抢红包插件实现","slug":"QQ红包插件实现","date":"2016-01-15T02:43:11.000Z","updated":"2016-07-11T04:23:34.752Z","comments":true,"path":"2016/01/15/QQ红包插件实现/","link":"","permalink":"http://tiandawu.github.io/2016/01/15/QQ红包插件实现/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前跟那些20年的单身狗抢红包是屡战屡败。再加上最近群里面发红包发的厉害，又想到快要过年了，到时候还不知道群里要发好多红包，所以我将之前在网上宕的一份微信抢红包的代码修改了一下，实现了QQ抢红包！可以支持抢QQ拼手气红包，普通红包，口令红包，现在再也不怕20年单身手速的人跟我抢红包了！","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前跟那些20年的单身狗抢红包是屡战屡败。再加上最近群里面发红包发的厉害，又想到快要过年了，到时候还不知道群里要发好多红包，所以我将之前在网上宕的一份微信抢红包的代码修改了一下，实现了QQ抢红包！可以支持抢QQ拼手气红包，普通红包，口令红包，现在再也不怕20年单身手速的人跟我抢红包了！ 先看测试效果图：1. 抢QQ口令红包： 可以看见，只要红包一发出，自动填写口令并发出，帮你将红包抢到手！ 2. 抢QQ拼手气红包： 拼手气红包也是一样，只要红包一发出，自动帮你把红包抢到手，是不是很爽的感觉？ 3. 抢QQ好友发送的红包： 只要好友或者群里的人把红包一发出，就会第一时间让你抢到红包！所以只要在群里面开启插件，抢红包从来都是百发百中！ 本插件主要是通过`AccessibilityService``来实现对屏幕的监控，从而实现抢红包的功能。代码比较少，下面从贴出源码来分析： MainActivity: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*MainActivity中的代码基本没改变：*/public class MainActivity extends AppCompatActivity &#123; private final Intent mAccessibleIntent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS); private Button switchPlugin; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); switchPlugin = (Button) findViewById(R.id.button_accessible); updateServiceStatus(); &#125; public void onButtonClicked(View view) &#123; startActivity(mAccessibleIntent); &#125; @Override protected void onResume() &#123; super.onResume(); updateServiceStatus(); &#125; private void updateServiceStatus() &#123; boolean serviceEnabled = false; AccessibilityManager accessibilityManager = (AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE); List&lt;AccessibilityServiceInfo&gt; accessibilityServices = accessibilityManager.getEnabledAccessibilityServiceList(AccessibilityServiceInfo.FEEDBACK_GENERIC); for (AccessibilityServiceInfo info : accessibilityServices) &#123; if (info.getId().equals(getPackageName() + \"/.QQHongbaoService\")) &#123; serviceEnabled = true; break; &#125; &#125; if (serviceEnabled) &#123; switchPlugin.setText(\"关闭插件\"); // Prevent screen from dimming getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; else &#123; switchPlugin.setText(\"开启插件\"); getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125;&#125; 这里是MainActivity中的全部代码，是不是很少的样子，主要是实现了一个按钮去开启ACCESSIBILITY_SERVICE。这个插件主要就是借助AccessibilityService这个服务来实现。所以剩下的核心功能代码就都在这个服务中了！ QQHongbaoService： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public class QQHongbaoService extends AccessibilityService &#123; private static final String WECHAT_OPEN_EN = \"Open\"; private static final String WECHAT_OPENED_EN = \"You've opened\"; private final static String QQ_DEFAULT_CLICK_OPEN = \"点击拆开\"; private final static String QQ_HONG_BAO_PASSWORD = \"口令红包\"; private final static String QQ_CLICK_TO_PASTE_PASSWORD = \"点击输入口令\"; private boolean mLuckyMoneyReceived; private String lastFetchedHongbaoId = null; private long lastFetchedTime = 0; private static final int MAX_CACHE_TOLERANCE = 5000; private AccessibilityNodeInfo rootNodeInfo; private List&lt;AccessibilityNodeInfo&gt; mReceiveNode; @TargetApi(Build.VERSION_CODES.KITKAT) public void recycle(AccessibilityNodeInfo info) &#123; if (info.getChildCount() == 0) &#123; if (info.getText() != null &amp;&amp; info.getText().toString().equals(QQ_CLICK_TO_PASTE_PASSWORD)) &#123; info.getParent().performAction(AccessibilityNodeInfo.ACTION_CLICK); &#125; if (info.getClassName().toString().equals(\"android.widget.Button\") &amp;&amp; info.getText().toString().equals(\"发送\")) &#123; info.performAction(AccessibilityNodeInfo.ACTION_CLICK); &#125; &#125; else &#123; for (int i = 0; i &lt; info.getChildCount(); i++) &#123; if (info.getChild(i) != null) &#123; recycle(info.getChild(i)); &#125; &#125; &#125; &#125; @TargetApi(Build.VERSION_CODES.JELLY_BEAN) @Override public void onAccessibilityEvent(AccessibilityEvent event) &#123; this.rootNodeInfo = event.getSource(); if (rootNodeInfo == null) &#123; return; &#125; mReceiveNode = null; checkNodeInfo(); /* 如果已经接收到红包并且还没有戳开 */ if (mLuckyMoneyReceived &amp;&amp; (mReceiveNode != null)) &#123; int size = mReceiveNode.size(); if (size &gt; 0) &#123; String id = getHongbaoText(mReceiveNode.get(size - 1)); long now = System.currentTimeMillis(); if (this.shouldReturn(id, now - lastFetchedTime)) return; lastFetchedHongbaoId = id; lastFetchedTime = now; AccessibilityNodeInfo cellNode = mReceiveNode.get(size - 1); if (cellNode.getText().toString().equals(\"口令红包已拆开\")) &#123; return; &#125; cellNode.getParent().performAction(AccessibilityNodeInfo.ACTION_CLICK); if (cellNode.getText().toString().equals(QQ_HONG_BAO_PASSWORD)) &#123; AccessibilityNodeInfo rowNode = getRootInActiveWindow(); if (rowNode == null) &#123; Log.e(TAG, \"noteInfo is null\"); return; &#125; else &#123; recycle(rowNode); &#125; &#125; mLuckyMoneyReceived = false; &#125; &#125; &#125; /** * 检查节点信息 */ private void checkNodeInfo() &#123; if (rootNodeInfo == null) &#123; return; &#125; /* 聊天会话窗口，遍历节点匹配“点击拆开”，“口令红包”，“点击输入口令” */ List&lt;AccessibilityNodeInfo&gt; nodes1 = this.findAccessibilityNodeInfosByTexts(this.rootNodeInfo, new String[]&#123; QQ_DEFAULT_CLICK_OPEN, QQ_HONG_BAO_PASSWORD, QQ_CLICK_TO_PASTE_PASSWORD, \"发送\"&#125;); if (!nodes1.isEmpty()) &#123; String nodeId = Integer.toHexString(System.identityHashCode(this.rootNodeInfo)); if (!nodeId.equals(lastFetchedHongbaoId)) &#123; mLuckyMoneyReceived = true; mReceiveNode = nodes1; &#125; return; &#125; &#125; /** * 将节点对象的id和红包上的内容合并 * 用于表示一个唯一的红包 * * @param node 任意对象 * @return 红包标识字符串 */ private String getHongbaoText(AccessibilityNodeInfo node) &#123; /* 获取红包上的文本 */ String content; try &#123; AccessibilityNodeInfo i = node.getParent().getChild(0); content = i.getText().toString(); &#125; catch (NullPointerException npe) &#123; return null; &#125; return content; &#125; /** * 判断是否返回,减少点击次数 * 现在的策略是当红包文本和缓存不一致时,戳 * 文本一致且间隔大于MAX_CACHE_TOLERANCE时,戳 * * @param id 红包id * @param duration 红包到达与缓存的间隔 * @return 是否应该返回 */ private boolean shouldReturn(String id, long duration) &#123; // ID为空 if (id == null) return true; // 名称和缓存不一致 if (duration &lt; MAX_CACHE_TOLERANCE &amp;&amp; id.equals(lastFetchedHongbaoId)) &#123; return true; &#125; return false; &#125; /** * 批量化执行AccessibilityNodeInfo.findAccessibilityNodeInfosByText(text). * 由于这个操作影响性能,将所有需要匹配的文字一起处理,尽早返回 * * @param nodeInfo 窗口根节点 * @param texts 需要匹配的字符串们 * @return 匹配到的节点数组 */ private List&lt;AccessibilityNodeInfo&gt; findAccessibilityNodeInfosByTexts(AccessibilityNodeInfo nodeInfo, String[] texts) &#123; for (String text : texts) &#123; if (text == null) continue; List&lt;AccessibilityNodeInfo&gt; nodes = nodeInfo.findAccessibilityNodeInfosByText(text); if (!nodes.isEmpty()) &#123; if (text.equals(WECHAT_OPEN_EN) &amp;&amp; !nodeInfo.findAccessibilityNodeInfosByText(WECHAT_OPENED_EN).isEmpty()) &#123; continue; &#125; return nodes; &#125; &#125; return new ArrayList&lt;&gt;(); &#125; @Override public void onInterrupt() &#123; &#125;&#125; QQHongbaoService的全部代码也在这里，代码也不多。首先，在这个服务中主要是通过findAccessibilityNodeInfosByText这个方法去获我们需要的节点；然后，用 performAction(AccessibilityNodeInfo.ACTION_CLICK) 这个方法去点击红包节点，关键思路大概就是这样！另外如果是口令红包，我们需要先按照上面的步骤将红包戳开，然后通过performAction(AccessibilityNodeInfo.ACTION_CLICK)去点击输入口令，最后再通过点击去发送即可实现！ QQHongbaoService需要在AndroidManifest.xml文件中注册，注册的节点如下图： 总体来看，只是将微信抢红包的代码做了少量的修改，在这里要感谢微信抢红包源码的贡献！最后也希望这篇文章能给大家有所帮助，在抢红包大战中百战百胜！ 下面是源码地址：点击：下载地址","categories":[{"name":"Android","slug":"Android","permalink":"http://tiandawu.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://tiandawu.github.io/tags/Android/"}]},{"title":"Hexo+github搭建个人博客","slug":"BuildMyBlog","date":"2016-01-14T02:43:11.000Z","updated":"2016-07-10T13:01:52.947Z","comments":true,"path":"2016/01/14/BuildMyBlog/","link":"","permalink":"http://tiandawu.github.io/2016/01/14/BuildMyBlog/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章主要讲解怎么利用Hexo和github来搭建自己的博客！如果你正想搭建一个属于自己的博客，那么就不妨动手跟我一起来搭建 ！","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章主要讲解怎么利用Hexo和github来搭建自己的博客！如果你正想搭建一个属于自己的博客，那么就不妨动手跟我一起来搭建 ！ 一.环境搭建&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在搭建之前我们首先要搭建环境，首先要做的是安装Git和Node.js(最好翻墙后打开)，先去这两个网站官网下载并安装好，安装的过程很简单，就是一路下一步即可！其次要做的是打开你的git Bash窗口，输入如下命令：1$ npm install -g hexo-cli 完成以上操作后，你就算将Hexo也安装好了，安装Hexo也可以参看Hexo的官网。至此，环境搭建已经完成！ 二.创建本地博客&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本地磁盘新建一个文件夹，我这里命名为：MyBlog，然后鼠标右击该文件夹，打开：Git Bash Here。在弹出的命令窗口中输入以下命令:1$ hexo init yourname.github.io 需要注意的是：这里需要将命令中的yourname替换成你的github的账户名，必须要是和账户名一致！执行完这条命令后就会在你刚才新建的文件夹下生成一个名字为：yourname.github.io的文件夹。然后，又执行如下几条命令：1234$ cd yourname.github.io //cd到刚才自动创建的目录下$ npm install$ hexo g$ hexo s 执行完以上命令后，不要关闭Git Bash窗口，用浏览器打开：http://localhost:4000/ 你就会看见自己的本地博客页面了，如图： 三.将本地博客部署到github上1. 在github上创建一个仓库按照下图创建：填写完成，点解Create repository完成创建即可！ 2. 将刚创建的远程仓库更新下来步骤如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依然是鼠标右击：yourname.github.io打开Git Bash Here,执行如下命令：1234$ git init //初始化git仓库$ git remote add origin git@github.com:yourname/yourname.github.io.git //将yourname替换//给远程仓库添加一个名为：origin 的引用$ git fetch origin //获取远程仓库的内容$ git merge origin/master //将获取的内容合并到master分支 3. 修改配置文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着用sublime或者notepad++打开：yourname.github.io文件夹下的这个文件：_config.yml，在文件最后做如下修改：1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 以下两步是有自己域名的看：如果你有自己的域名，可以将上面修改如下：12345deploy: type: git repo: git@github.com:tiandawu/tiandawu.github.io.git branch: master plugins: -hexo-generator-cname 另外还需要修改的是这里：1234url: http://tiandawu.com //这里改成自己的域名root: /permalink: :year/:month/:day/:title/permalink_defaults: 好了，至此配置文件修改完毕。 4. 部署到github&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依然来到刚才的Git Bash窗口，执行如下命令：有自己域名的需要先执行这条命令：1$ npm install hexo-generator-cname --save //这条命令执行过程较慢，耐心等待！(需要翻墙快) 下面的命令都需要执行：123$ git add .$ git commit -m \"输入自己的描述信息\"$ git push origin master 执行完上面的命令，没有配置自己域名的再执行下面两条命令就可访问自己的博客了：(在浏览器中输入：yourname.github.io访问)12$ hexo g$ hexo d 注意：在执行：$ hexo d的时候如果出现下面的错误：这时候只需要先执行这条命令:1$ npm install hexo-deployer-git --save 然后后再执行下面这条部署命令就行了！1$ hexo d 配置了自己域名的还需要执行完下面的命令：12$ git fetch origin$ git merge origin/master 配置了自己域名的还需要修改CNAME文件，public文件夹下的CNAME也要修改，都填写上自己的域名即可！可以参考我填写的CNAME文件。配置了自己域名的最后执行下面命令也能访问了：（可以通过：yourname.github.io或你的域名访问）12345$ git add .$ git commit -m \"输入自己的描述信息\"$ git push origin master$ hexo g$ hexo d 不管你有没有自己的域名，现在如果你能通过以上两种方式看到这个页面就算你搭建成功了（恭喜！）： 四.配置Next主题Hexo提供了很多的主题，可以参考丰富多彩的Hexo主题，这里我选用的是配置Next主题，我的博客样式。具体配置详情，请参考：Next主题官方文档。 五.搭建遇到的坑我在将主题设置成Next后，在将仓库向github提交了一遍，结果就收到一封这样的邮件： 于是我就点了链接，看到给的解决方案是这样的： 于是我就按照这个方法做，结果出现下面的错误： 经过几番尝试，我将之前更新下来的主题全删掉，然后输入下面的命令去下载主题： git submodule add https://github.com/iissnan/hexo-theme-next如图： 这样更新下主题后，发现在：yourname.github.io文件夹下会多出一个.gitmodules的文件，然后我在按照之前的方法尝试，结果就不出现那个错误，将文件push到远程仓库也不会收到刚才那邮件了，这个坑就这样被填上了！","categories":[],"tags":[]}]}