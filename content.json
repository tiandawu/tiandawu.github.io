{"meta":{"title":"Devbird's blog","subtitle":null,"description":null,"author":"devbird","url":"http://tiandawu.github.io"},"pages":[{"title":"Categories","date":"2016-07-11T02:20:38.336Z","updated":"2016-07-11T02:20:38.336Z","comments":true,"path":"categories/index.html","permalink":"http://tiandawu.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-07-11T02:20:38.336Z","updated":"2016-07-11T02:20:38.336Z","comments":true,"path":"tags/index.html","permalink":"http://tiandawu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Intent和IntentFilter","slug":"Intent和IntentFilter","date":"2016-09-02T09:35:27.000Z","updated":"2016-09-02T09:37:05.442Z","comments":true,"path":"2016/09/02/Intent和IntentFilter/","link":"","permalink":"http://tiandawu.github.io/2016/09/02/Intent和IntentFilter/","excerpt":"作为四大组件的枢纽，Intent和IntentFilter起着功不可没的作用，所以有必要好好做个总结。","text":"作为四大组件的枢纽，Intent和IntentFilter起着功不可没的作用，所以有必要好好做个总结。 一、IntentIntent分为两种类型：显式Intent、隐式Intent 显示Intent:指定要启动组件的名称(类的全路径名) 12345// Executed in an Activity, so &apos;this&apos; is the Context// The fileUrl is a string URL, such as &quot;http://www.example.com/image.png&quot;Intent downloadIntent = new Intent(this, DownloadService.class);downloadIntent.setData(Uri.parse(fileUrl));startService(downloadIntent); 隐式Intent:不指定特定的组件，而是通过设置常规操作，如：Action、Data、Category 12345678910// Create the text message with a stringIntent sendIntent = new Intent();sendIntent.setAction(Intent.ACTION_SEND);sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);sendIntent.setType(&quot;text/plain&quot;);// Verify that the intent will resolve to an activityif (sendIntent.resolveActivity(getPackageManager()) != null) &#123; startActivity(sendIntent);&#125; 在构造Intent的时候可以给这个Intent指定这些信息：Component name、Action、Data、Category、Extras、Flags ①Component name:主要是用来指定组件名称，可以通过setComponent()、setClass()、setClassName() 或者直接通过Intent的构造函数来指定组件名称。示例：1234567Intent intent = new Intent();//Intent intent = new Intent(this, BJActivity.class);//通过构造函数指定组件名ComponentName component = new ComponentName(this, BJActivity.class);intent.setComponent(component);//通过setComponent()方法指定组件名//intent.setClass(this, BJActivity.class);//通过setClass()指定组件名//intent.setClassName(this, &quot;com.tiandawu.nougat.BJActivity&quot;);//通过setClassName()指定组件名startActivity(intent); ② Action:主要用来指定Intent的动作，可以通过setAction() 来指定Intent的动作。示例：1234Intent intent = new Intent();intent.setAction(Intent.ACTION_CALL);//拨打电话的动作intent.setData(Uri.parse(&quot;tel:10086&quot;));//携带的数据this.startActivity(intent); Action的种类很多，具体种类可以去官网的Intent类中查看。 ③ Data:主要用来指定Intent携带的数据，可以通过setData() 来指定Intent携带的数据。例如上面的例子中就就通过setData 来指定携带了电话号码。 setData()和setType()的注意事项：当要指定data和type的时候请使setDataAndType()，因为用setData和setType()来分别制定data和type时，setData()和setType()都会清除对方的值。 ④ Category:主要用于隐式Intent，用来指定类别，通过addCategory() 来指定类别。主要用途是用来匹配Intent-Filter中的&lt;category&gt; 标签中的元素。后面会在IntentFilter中作详细讲解。 ⑤ Extras: 主要用于携带完成请求操作所需的附加信息的键值对，通过putExtra() 方法来存入键值对。示例：12intent.putExtra(&quot;strKey&quot;, &quot;strValue&quot;);//存入一个字符串键值对intent.putExtra(&quot;intKey&quot;, 20);//存入一个int型的键值对 putExtra() 能存入很多基本数据类型，还可以put对象，通过这个方法就可以完成Activity之间的数据交互。 Flags 见名思意，可以用来携带标志，通过setFlags() 就可以指定所需要的标志。示例：1234Intent intent = new Intent();intent.setClass(this, MyActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);//新开一个任务栈，来启动ActivitystartActivity(intent); 能指定的Flags有很多，具体的Flags有哪些可以去官网的Intent类中查看。 二、IntentFilterIntentFilter是用来过滤Intent的，当用隐式Intent来启动一个Activity的时候，就会匹配Intent携带的信息和intent-filter 中的过滤信息，当这些信息匹配成功则启动Activity。intent-filter 的过滤信息分为三类，分别是：action类、category类、data类。一个&lt;Activity&gt; 节下面可以包含多个&lt;intent-filter&gt; 节，当一个Intent能匹配任何一个&lt;intent-filter&gt; 中的action类、category类 和 data类 时则匹配成功，此时才能启动目标Activity。 下面是一个Activity中的过滤规则示例：123456789101112131415161718&lt;activity android:name=&quot;.TestActivity&quot; &gt; &lt;!--第一组intent-filter--&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.tdw.action_1&quot; /&gt; &lt;action android:name=&quot;com.tdw.action_2&quot; /&gt; &lt;category android:name=&quot;com.tdw.category_1&quot; /&gt; &lt;category android:name=&quot;com.tdw.category_2&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:mimeType=&quot;image/*&quot; /&gt; &lt;data android:mimeType=&quot;video/*&quot; /&gt; &lt;/intent-filter&gt; &lt;!--第二组intent-filter--&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.tdw.action_group_2&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:mimeType=&quot;image/*&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 在这个&lt;Activity&gt;中有两组&lt;intent-filter&gt;，只要一个Intent能匹配其中任意一组&lt;intent-filter&gt;即可。这里的匹配是指需要同时匹配一组中的action类别、categroy类别和data类别。下面分别详细介绍这三个类别的匹配规则。 1、action 的匹配规则从上面的例子中可以看出，一个intent-filter中可以有多个action，如果Intent中的action和过滤规则中action的字符串相同(区分大小写)，则匹配。如果intent-filter中有多个action，那么只要匹配上过滤规则中的一个action也算匹配成功。如果Intent中没有指定action或则与intent-filter中的action一个也没匹配上，则匹配失败。比如：Intent中action的值为com.tdw.action_1 或 com.tdw.action_2就算匹配成功，如果一个都不相同则匹配失败。 2、category 的匹配规则category 的匹配规则和action的匹配规则有所不同。如果Intent中携带了category，不管有几个category，对于携带的每个category 来说，它必须是过滤规则中已经定义好了的category。但是Intent中也可以没有携带category，如果没有的话也可以匹配成功，因为系统在调用startActivity 或者 startActivityForResult 的时候会默认为Intent加上“android.intent.category.DEFAULT”这个category。与action 不同的是，action 是要求Intent中必须有一个action 且必须能够和过滤规则中的某个action 相同。 3、data的匹配规则要了解data 的匹配规则首先要了解data 的语法，所以还是先来学习data 的语法。 data 的语法示例：12345678&lt;data android:scheme=&quot;string&quot; android:host=&quot;string&quot; android:por=&quot;string&quot; android:path=&quot;string&quot; android:pathPattern=&quot;string&quot; android:pathPrefix=&quot;string&quot; android:mimeType=&quot;string&quot;/&gt; data 由两部份组成，mimeType和URI。mimeType指媒体类型，比如：image/jpeg 和 video/* 可以分别表示图片和视频。mimeType的媒体类型有很多，具体需要用时可以去查看。而URI中包含的数据就比较多了，URI的结构如下： &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 具体示例：content://com.example.project:200/folder/subfolder/ethttp://www.google.com:80/search/info 通过两个具体示例和URI的结构示例对照看就很清楚URI的含义了。scheme: URI的模式，比如http、file、content等，如果URI中没有指定scheme,那么整个URI的其他参数无效，这也意味着URI无效。host: URI的主机名，比如：www.google.com，如果host为指定，那么整个URI的其他参数无效，这也意味着着URI无效。port: URI的端口号，比如：80，仅当URI中指定了scheme和host参数的时候port参数才是有意义的。path、pathPattern、和pathPrefix: 这三个参数表述路径信息，其中path表示完整的路径信息； pathPattern也表示完整的路径信息，大师它里面可以包含通配符(*), 通配符(*) 表示0个或多个任意字符，需要注意的是，由于正则表达式的规范，如果想表示真实的字符串，那么* 要写成\\\\* ,\\要写成\\\\\\;pathPrefix 表示路径的前缀信息。 data 的匹配规则和action 类似，它也要求Intent中必须含有data 数据，并且data 数据能够完全匹配过滤规则中的某一个data。这里的完全匹配是指过滤规则中出现的data 部分也出现在了Intent中的data 中。 示例1： 1234&lt;intent-filter&gt; &lt;data android:mimeType=&quot;image/*&quot; /&gt; ...&lt;/intent-filter&gt; 这个示例当中，mimeType指定的媒体类型是图片，那么Intent中的mimeType属性也必须为”image/*“才能匹配，这种情况下虽然没有指定URI，但是确是有默认值，URI的默认值为content和file。也就是说，虽然没有指定URI,但是Intent中的URI部分的scheme 必须为content或则file才能匹配。所以Intent中的scheme 可以这么写： intent.setDataAndType(Uri.parse(“file://abc”),”image/*”) 注意的是：如果要为Intent指定完整的data ，必须用setDataAndType 方法，不能先调用setData 再调用setType ,因为这两个方法在调用时会彼此清除对方的值。 示例2： 12345&lt;intent-filter&gt; &lt;data android:mimeType=&quot;video/mpeg&quot; android:schema=&quot;http&quot; .../&gt; &lt;data android:mimeType=&quot;audio/mpeg&quot; android:scheme=&quot;http&quot; .../&gt; ...&lt;/intent-filter&gt; 这种规则指定了两组data 规则，且每个data 都指定了完整的属性值，既有URI又有mimeType。为了匹配示例2中的规则，可以在写出如下示例： intent.setDataAndType(Uri.parse(“http://abc&quot;),&quot;video/mpeg“) 或则是 intent.setDataAndType(Uri.parse(“http://abc&quot;),&quot;audio/mpeg“) 示例3：12345678910111213&lt;!--第一种--&gt;&lt;intent-filter&gt; &lt;data android:scheme=&quot;file&quot; android:host=&quot;www.google.com&quot; /&gt; ...&lt;/intent-filter&gt;&lt;!--第二种--&gt;&lt;intent-filter&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:host=&quot;www.google.com&quot; /&gt; ...&lt;/intent-filter&gt; 这是 data 特殊情况，如上两种写法，作用是一样的。 参考书籍： Android开发艺术探索参考网站： Android官方文档","categories":[{"name":"Android总结","slug":"Android总结","permalink":"http://tiandawu.github.io/categories/Android总结/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://tiandawu.github.io/tags/Android/"}]},{"title":"Nougat多窗口支持","slug":"Nougat多窗口支持","date":"2016-08-29T09:12:18.000Z","updated":"2016-09-02T09:29:28.823Z","comments":true,"path":"2016/08/29/Nougat多窗口支持/","link":"","permalink":"http://tiandawu.github.io/2016/08/29/Nougat多窗口支持/","excerpt":"在Android7.0中引入了类似PC上多窗口的支持，屏幕上能同时显示多个，用户在与另一个应用交互的同时可以继续播放视频。如果是用N Preview SDK构建应用,则可以配置应用的多窗口显示方法。","text":"在Android7.0中引入了类似PC上多窗口的支持，屏幕上能同时显示多个，用户在与另一个应用交互的同时可以继续播放视频。如果是用N Preview SDK构建应用,则可以配置应用的多窗口显示方法。 一、多窗口预览 1. 预览图如下： 2. 用户切换到多窗口模式的方法： 若用户打开 Overview 屏幕并长按 Activity 标题，则可以拖动该 Activity 至屏幕突出显示的区域，使 Activity 进入多窗口模式。 若用户长按 Overview 按钮，设备上的当前 Activity 将进入多窗口模式，同时将打开 Overview 屏幕，用户可在该屏幕中选择要共享屏幕的另一个 Activity。 二、多窗口模式配置在清单文件（AndroidManifest.xml）中可以对应用的Activit是否支持多窗口显示以及显示方式进行配置。 1. 配置是否支持多窗口： 在清单文件的 &lt;activity&gt; 或 &lt;application&gt; 节点中设置该属性，启用或禁用多窗口显示： 1android:resizeableActivity=[&quot;true&quot; | &quot;false&quot;] 如果该属性设置为 true，Activity 将支持多窗口模式。 如果此属性设置为 false，Activity 将不支持多窗口模式,且用户尝试在多窗口模式下启动 Activity，该 Activity 将全屏显示。如果是用Android N SDK构建应用，但未对该属性指定值，则该属性的值默认设为 true。 2. 对多窗口显示方式进行配置： Android N 在清单文件的 &lt;Activity&gt; 节点下增加了一个 &lt;layout&gt; 标签。该标签支持一下几种属性： 12345678910android:defaultWidth //多窗口模式下Activity 的默认宽度android:defaultHeight //多窗口模式下Activity 的默认高度android:gravity //多窗口模式下Activity 的初始位置android:minHeight //多窗口模式下Activity 的最小高度android:minWidth //多窗口模式下Activity 的最小宽度/*ps: android:minimalWidth 已经被替换成 android:minWidth android:minimalHeight 已经被替换成 android:minHeight 如果还是使用：android:minimalHeight 和 android:minimalWidth 编译不会通过。*/ 例如：以下节点显示了如何指定Activity在多窗口模式中显示的大小、位置和最小尺寸： 12345678910&lt;activity android:name=&quot;.MyActivity&quot; android:resizeableActivity=&quot;true&quot;&gt; &lt;layout android:defaultHeight=&quot;500dp&quot; android:defaultWidth=&quot;600dp&quot; android:gravity=&quot;top|end&quot; android:minHeight=&quot;450dp&quot; android:minWidth=&quot;300dp&quot; /&gt; &lt;/activity&gt; 3. 多窗口模式禁用的功能： 无法隐藏状态栏 系统将忽略对 android:screenOrientation 属性所作的更改 4. 多窗口模式下常用的方法： Activity.isInMultiWindowMode()；调用该方法以确认 Activity 是否处于多窗口模式。 Activity.onMultiWindowModeChanged()；Activity 进入或退出多窗口模式时系统将调用此方法。 在 Activity 进入多窗口模式时，系统向该方法传递 true 值，在退出多窗口模式时，则传递 false 值。 5. 在多窗口模式中启动新 Activity如果当前应用处于多窗口模式，想要在该应用启动的Activity显示在当前 Activity 旁边，则需要使用标志位：Intent.FLAG_ACTIVITY_LAUNCH_ADJACENT 和 Intent.FLAG_ACTIVITY_NEW_TASK例如： 1234Intent intent = new Intent();intent.setClass(this, MyActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_LAUNCH_ADJACENT|Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 启动后两个Activity处于分屏模式，如图： 如果处于多窗口模式下，可以通过调用 ActivityOptions.setLaunchBounds() 指定新 Activity 的尺寸和屏幕位置，如果不处于多窗口模式则该方法无效。示例代码： 123456789Rect rect = new Rect(0,400,800,1000);ActivityOptions options = ActivityOptions.makeBasic();options.setLaunchBounds(rect);Intent intent = new Intent();intent.setClass(this, MyActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_LAUNCH_ADJACENT|Intent.FLAG_ACTIVITY_NEW_TASK);ActivityCompat.startActivity(this,intent,options.toBundle()); 三、多窗口的生命周期多窗口模式下Activity的生命周期并没有改变，只是在切换到多窗口和退出多窗口模式时有所不同。在这两种切换过程中Activity会被销毁后重新创建，所以在这两种模式下应该通过：onSaveInstanceState 和 onRestoreInstanceState 这两个方法做好数据的保存和恢复。 如果在多窗口模式下播放视频，应该在 onStop() 和 onStart() 这两个方法中去暂停和继续播放，这样会有更好的用户体验。 四、多窗口模式下数据拖放多窗口模式下的拖放，仅仅是数据的拖放，并不能将一个Activity的View拖放到另一个Activity。跨Activity拖放需要：View.DRAG_FLAG_GLOBAL 这个标志。例如从MainActivity拖放一个按钮中的数据到MyActivity中： MainActivity:1234567891011btn = (Button) findViewById(R.id.my_button); btn.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View view) &#123; ClipData data = ClipData.newPlainText(view.getClass().getName(), ((Button) view).getText()); View.DragShadowBuilder builder = new View.DragShadowBuilder(view); view.startDragAndDrop(data, builder, view, View.DRAG_FLAG_GLOBAL);//跨Activity拖放需要这个标志位 return true; &#125; &#125;); MyActivity： 1234567891011121314textView = (TextView) findViewById(R.id.text);View parent = (View) textView.getParent(); parent.setOnDragListener(new View.OnDragListener() &#123; @Override public boolean onDrag(View v, DragEvent event) &#123; switch (event.getAction()) &#123; case DragEvent.ACTION_DROP: ClipData.Item item = event.getClipData().getItemAt(0); textView.setText(item.getText()); break; &#125; return true; &#125; &#125;); 实现效果图：","categories":[{"name":"Android","slug":"Android","permalink":"http://tiandawu.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://tiandawu.github.io/tags/Android/"}]},{"title":"sql笔记","slug":"sql笔记","date":"2016-07-12T04:50:42.000Z","updated":"2016-07-12T05:07:20.078Z","comments":true,"path":"2016/07/12/sql笔记/","link":"","permalink":"http://tiandawu.github.io/2016/07/12/sql笔记/","excerpt":"sql语句是数据库很重要的一部分，这篇文章主要记录了一些基本的sql语法，包括对数据库的操作、对表的增删改查、以及数据约束和多表查询等。","text":"sql语句是数据库很重要的一部分，这篇文章主要记录了一些基本的sql语法，包括对数据库的操作、对表的增删改查、以及数据约束和多表查询等。 一、数据库管理 查询所有数据库 show databases; 创建数据库 create database test; 查看数据库的默认字符集show create database test; 删除数据库drop database test; 修改数据库默认字符集alter database test default character set utf8; 二、表管理 查看所有表 show tables; 创建表 create table student(id int,name varchar(20),age int); 查看表结构 desc student; 删除表 drop table student; 修改表 添加字段 alter table student add column gender varchar(10); 删除字段 alter table student drop column gender; 修改字段类型 alter table student modify column age varchar(10); 修改字段名称 alter table student change column name sname varchar(20); 修改表名称 alter table student rename to teacher; 增删改数据 增加数据 插入所有字段 insert into student values(1,&#39;devbird&#39;,10); 插入部分字段 insert into student(id,name) values(2,&#39;dawu&#39;) 修改数据 update student set age=20,gender=&#39;男&#39; where id=1; 删除数据 带条件的删除 delete from student where id=2; 删除所有数据 方式一：delete from student; 方式二：truncate table student; 两种方式区别： delete from: ①可以带条件删除；②只能删除表的数据，不能删除表的约束；③使用delete from删除的数据可以回滚（事务）。 truncate table:①不能带条件删除；②既可以删除表的数据，也可以删除表的约束；③使用truncate table删除的数据不能回滚（事务）。 查询数据 查询所有列 select * from student; 查询指定列 select id,name from student; 查询时添加常量列class select id,name,&#39;class&#39; from student; 查询时合并列 select id name,(math+english) as &#39;总成绩&#39; from student; 查询时去除重复记录 select distinct gender from student; 条件查询 逻辑条件： and(与) or(或) select * from student where id=1 and name=&#39;devbird&#39;; select * from student where id=1 or name=&#39;devbird&#39;; 比较条件：&gt;, &lt;, &gt;=, &lt;=, =, &lt;&gt;(不等于), between A and B(等价于&gt;=A 且&lt;=B) select * from student where math&gt;60; select * from student where math&gt;=60 and math&lt;=90; select * from student where math between 60 and 90; select * from student where age&lt;&gt;20; 判空条件：is null, is not null, =’’, &lt;&gt;’’ select * from student where address is null; select * from student where address=&#39;&#39;; 模糊条件：like %:表示任意个字符； _：表示一个字符； 查询姓李的学生：select * from student where name like &#39;李%&#39;; 查询姓李且名字只有两个字的学生：select * from student where name like &#39;李_&#39;; 聚合查询 -常用的聚合函数：sum(), max(), min(), avg(), count() 查询学生math的总成绩：select sum(math) as &#39;数学总成绩&#39; from student; 查询math最高分：select max(math) as &#39;最高分&#39; from student; 查询math最低分：select min(math) as &#39;最低分&#39; from student; 查询math平均分：select avg(math) as &#39;数学平均分&#39; from student; 统计有多少学生：select count(*) from student; 分页查询 分页： limit 其实行，查询几行 分页查询当前页数据的sql：select * from student limit (当前页-1)*每页显示多少条，每页显示多少条; 查询排序 语法：order by 字段 asc/desc (asc:升序；desc:降序) select * from student order by math asc; select * from student order by math desc; 分组查询 按性别分组：select * from student group by gender; 统计每组的人数：select gender,count(*) from student group by gender; 分组查询后筛选 -查询总人数大于二的性别：select gender,count(*) from student group by gender having count(*)&gt;2; 三、数据约束 默认值 create table student(id int,name varchar(20),address varchar(30) default &#39;重庆&#39;); 非空 create table student(id int,name varchar(20),gender varchar(10) not null); 唯一 create table student(id int unique,name varchar(20)); 主键 create table student(id int primary key,name varchar(20)); 自增长 create table student(id int primary key auto_increment,name varchar(20)); 外键 主表：create table dept(id int primary key,deptName varchar(20)); 副表：create table employee(id int primary key,empName varchar(20),deptId int,constraint employee_dept_fk foreign key(deptId) references dept(id)); 当有了外键约束，添加数据的顺序： 先添加主表，再添加副表数据。 当有了外键约束，修改数据的顺序： 先修改副表，再修改主表数据。 当有了外键约束，删除数据的顺序： 先删除副表，再删除主表数据。 级联操作 级联修改： ON UPDATE CASCADE 级联删除： ON DELETE CASCADE 主表：create table dept(id int primary key,deptName varchar(20)); 副表：create table employee(id int primary key,empName varchar(20),deptId int,constraint employee_dept_fk foreign key(deptId) references dept(id) on update cascade on delete cascade); 四、多表查询 内连接查询 方式一：select empName,deptName from employee,dept where employee.deptId=dept.id; 方式二：select empName,deptName from employee inner join dept on employee.deptId=dept.id; 使用别名：SELECT e.empName,d.deptName FROM employee e INNER JOIN dept d ON e.deptId=d.id; 左[外]连接查询 SELECT d.deptName,e.empName FROM dept d LEFT OUTER JOIN employee e ON d.id=e.deptId; 用左边表的数据去匹配右边表的数据，如果符合连接条件的结果则显示，如果不符合连接条件则显示null,左外连接：左表的数据一定会完成显示! 右[外]连接查询 SELECT d.deptName,e.empName FROM employee e FROM employee e RIGHT OUTER JOIN dept d ON d.id=e.deptId; 使用右边表的数据去匹配左边表的数据，如果符合连接条件的结果则显示，如果不符合连接条件则显示null,右外连接：右表的数据一定会完成显示！ 自连接查询 SELECT e.empName,b.empName FROM employee e LEFT OUTER JOIN employee b ON e.bossId=b.id;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://tiandawu.github.io/categories/笔记/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tiandawu.github.io/tags/学习笔记/"}]},{"title":"Android中实现自定义XMPP消息包收发","slug":"Android中实现自定义XMPP消息包收发","date":"2016-06-05T01:46:14.000Z","updated":"2016-07-12T05:12:27.031Z","comments":true,"path":"2016/06/05/Android中实现自定义XMPP消息包收发/","link":"","permalink":"http://tiandawu.github.io/2016/06/05/Android中实现自定义XMPP消息包收发/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Android平台实现XMPP即时通讯主要是使用asmack这个包，asmack是XMPP协议的实现。但是asmack只能帮助我们实现一些基本消息包的收发，如果需要实现特定的自定义消息包收发需要我们自己处理。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Android平台实现XMPP即时通讯主要是使用asmack这个包，asmack是XMPP协议的实现。但是asmack只能帮助我们实现一些基本消息包的收发，如果需要实现特定的自定义消息包收发需要我们自己处理。 一、asmack消息的发送和接收 发送Message消息： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发送一个message结的消息，可以使用sendMessage()发送消息，这个方法有两个重载方法，一种类型的参数是String类型，另一种则是传入Message对象。String类型的方法传入的字符串即为要发送的消息；传入message对象的方需要写一个类继承Message，重写toXML()方法，toXML()方法的返回值即为要发送的消息。例如：123456789101112131415161718192021222324252627282930313233//1、通过传入String类型的sendMessage()方法发送消息：ChatManager chatManager = xmppConnection.getChatManager(); /** * String userJID 对方的JID * MessageListener listener 消息监听，当收到消息后会回调processMessage(Chat chat, Message message)方法 */Chat mChat = chatManager.createChat(mToUser, this);mChat.sendMessage(\"your content\");//2、通过传入Message对象的sendMessage()方法发送消息：/***写一个类继承Message重写toXML()方法，方法的返回值即为要发送的消息*/public class MyMessage extends Message &#123; @Override public String toXML() &#123; return \"your content\"; &#125;&#125;ChatManager chatManager = xmppConnection.getChatManager(); /** * String userJID 对方的JID * MessageListener listener 消息监听，当收到消息后会回调processMessage(Chat chat, Message message)方法 */Chat mChat = chatManager.createChat(mToUser, this);MyMessage myMessage = new MyMessage();mChat.sendMessage(myMessage); 接收Message消息： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接收Message类型的消息主要是在processMessage(Chat chat, Message message)方法中，当收到消息后都会回调这个方法，需要实现MessageListener这个接口，然后实现接口中的processMessage(Chat chat, Message message)方法。 二、发送和接收自定义类型的IQ结消息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当发送的iq消息中包含自定义的xml结的时候，asmack提供的解析并不能识别这些自定义的xml结，所以就需要我们自己实现消息包的解析和拼装。 1、发送含自定义xml结的iq消息：例如发送这样一个iq消息：&lt;iq id=&#39;123&#39; type=&#39;get&#39; from=&#39;client@xmpp/B&#39; to=&#39;client2@xmpp/s2&#39;&gt;&lt;req var=&#39;read&#39;&gt;&lt;attr var=&#39;temprature&#39;/&gt;&lt;/req&gt;&lt;/iq&gt; 1234567891011121314151617//步骤：//1、写一个类继承IQ并重写getChildElementXML()方法，该方法的返回值将作为消息体。public class MyIQ extends IQ &#123; @Override public String getChildElementXML() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"&amp;lt;req var='read'&amp;gt;&amp;lt; attr var='temprature'/&amp;gt;&amp;lt;/req&amp;gt;\"); return stringBuilder.toString(); &#125;&#125;//2、发送这个含自定义xml结的iq消息包MyIQ packet = new MyIQ();packet.setType(IQ.Type.GET);//设置IQ结type packet.setFrom(\"client@xmpp/B\");//设置IQ结from packet.setTo(\"client2@xmpp/s2\");//设置IQ结to xmppConnection.sendPacket(packet);//发送消息包 2、解析服务器返回的iq消息包，消息包中含自定义xml结：例如解析服务器返回的这样一个iq消息：&lt;iq id=&#39;12&#39; type=&#39;result&#39; from=&#39;client2@xmpp/s2&#39; to=&#39;client@xmpp/B&#39;&gt;&lt;resp xmlns=&#39;data&#39;&gt;&lt;attr var=&#39;temprature&#39;&gt;17&lt;/attr&gt;&lt;/resp&gt;&lt;/iq&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//步骤：//1、写一个类 implements PacketListener接口并实现其中的processPacket(Packet packet)方法。public class MyPacketListener implements PacketListener &#123; @Override public void processPacket(Packet packet) &#123; //当收到消息包就会回调该方法 &#125;&#125;//2、添加包监听器MyPacketListener mMyPacketListener = new MyPacketListener();//该方法有两个参数//第一个参数： PacketListener 包监听器//第二个参数： PacketFilter 包过滤器xmppConnection.addPacketListener(mMyPacketListener, null);//完成以上两步后，当收到消息包都会回调MyPacketListener中的processPacket(Packet packet)方法。//3、写一个类继承IQ并实现getChildElementXML()方法。public class GetDataResp extends IQ &#123; //例如我们要获取上面iq消息包中的temprature和17两个属性,所以将这两个值声明为成员变量,并生成get和set方法。 public String var; public String value; public String getVar() &#123;return var;&#125; public void setVar(String var) &#123;this.var = var;&#125; public String getValue() &#123;return value;&#125; public void setValue(String value) &#123;his.value = value;&#125; @Override public String getChildElementXML()&#123; //拼装消息 StringBuilder buf = new StringBuilder(); buf.append(\"&amp;lt;resp xmlns='get:data'&amp;gt;&amp;lt;attr var='\");· buf.append(getVar()); buf.append(\"'&gt;\"); buf.append(getValue()); buf.append(\"&amp;lt;/attr&amp;gt;&amp;lt;/resp&amp;gt;\"); return buf.toString(); &#125;&#125;//4、写一个类implements IQProvider并实现接口中的parseIQ(XmlPullParser parser)方法。public class GetDataRespProvider implements IQProvider &#123; @Override public IQ parseIQ(XmlPullParser parser) throws Exception &#123; GetDataResp getDataResp = new GetDataResp();//这个对象是上面第三步中的那个类对象 boolean done = false; while (!done) &#123; int eventType = parser.next(); if (eventType == XmlPullParser.START_TAG) &#123; if (parser.getName().equals(\"attr\")) &#123; String var = parser.getAttributeValue(\"\", \"var\");//获取var属性的value即：temprature String value = parser.nextText();//获取attr的文本即：17 getDataResp.setVar(var); getDataResp.setValue(value); &#125; &#125;else if (eventType == XmlPullParser.END_TAG) &#123; if (parser.getName().equals(\"resp\")) &#123; done = true; &#125; &#125; &#125; return getDataResp; &#125;&#125;//5、在配置ConnectionConfiguration时添加IQProvider//第一个参数是：String 元素的名称//第二个参数是：String 命名空间//第三个参数是：Object 需要传入一个prvider对象ProviderManager.getInstance().addIQProvider(\"resp\", \"data\", new GetDataRespProvider());//6、在第一步MyPacketListener中的processPacket(Packet packet)方法中获取相应消息包public class MyPacketListener implements PacketListener &#123; @Override public void processPacket(Packet packet) &#123; if (packet instanceof GetDataResp) &#123; GetDataResp getDataResp = (GetDataResp) packet; String from = getDataResp.getFrom(); String to = getDataResp.getTo(); String var = getDataResp.getVar(); String value = getDataResp.getValue(); &#125; &#125;&#125; 三、总结 发送message类型的消息中如果带有自定义xml结,需要写一个类继承Message并重写toXML()方法，该方法的返回值便是消息体。 发送的iq类型的消息中如果带有自定义xml结，需要写一个类继承IQ并重写getChildElementXML()方法，该方法的返回值将作为消息体 服务器返回的iq消息类型中如果带有自定义的xml结： 写一个类继承IQ并重写getChildElementXML()方法，将服务器返回的消息中需要的信息做成成员变量，并拼装出消息体，最后作为返回值返回。 写一个类implements IQProvider并实现接口中的parseIQ(XmlPullParser parser)方法，然后在该方法中做出对应的解析过程，最后通过返回值返回上一个步骤中的IQ对象。 服务器返回的iq消息中的消息体必须带有命名空间。 需要通过这个方法ProviderManager.getInstance().addIQProvider(&quot;resp&quot;, &quot;data&quot;, new GetDataRespProvider());添加相应的IQProvider。 如果需还需要实现一些自定义的解析，可以修改asmack源码中的PacketParserUtils这个类中对应的方法。 下面是源码地址：点击：下载地址","categories":[{"name":"Android","slug":"Android","permalink":"http://tiandawu.github.io/categories/Android/"}],"tags":[{"name":"XMPP","slug":"XMPP","permalink":"http://tiandawu.github.io/tags/XMPP/"}]},{"title":"正则表达式学习笔记","slug":"正则表达式学习笔记","date":"2016-02-27T06:40:35.000Z","updated":"2016-07-12T04:51:36.970Z","comments":true,"path":"2016/02/27/正则表达式学习笔记/","link":"","permalink":"http://tiandawu.github.io/2016/02/27/正则表达式学习笔记/","excerpt":"这篇文章主要记录了正则表达式的一些基本语法、修正模式和php常用的正则表达式函数！","text":"这篇文章主要记录了正则表达式的一些基本语法、修正模式和php常用的正则表达式函数！ 一、正则表达式基本语法： 界定符 原子 元字符 量词 边界控制 模式单元 1. 界定符 表示一个正则表达式的开始和结束。（如：/[0-9]/或#[0-9]#或{[0-9]}） 一般使用/或#作为界定符，不建议用{} 2. 原子 （1）可见原子：Unicode编码表中用键盘输出后肉眼可见的字符 如：标点；\"_?.等，英文字母数字a-z A-Z 0-9,其他可见字符等 （2）不可见原子：Unicode编码表中用键盘输出后肉眼不可见的字符 如：换行符\\n,回车\\r,制表符\\t，空格,其他不可见符号 3. 元字符 （1）原子的筛选方式： | 匹配两个或者多个分支选择; [] 匹配方括号中的任意一个原子; [^] 匹配除方括号中的原子之外的任意字符; （2）原子的集合： . 匹配除换行符之外的任意字符,即[^\\n]; \\d 匹配任意一个十进制数字，即[0-9]; \\D 匹配任意一个非十进制数字，即[^0-9]; \\s 匹配一个不可见原子，即[\\f\\n\\r\\t\\v]; \\S 匹配一个可见原子，即[^\\f\\n\\r\\t\\v]; \\w 匹配任意一个数字、字母或下划线，即[0-9a-zA-Z_]; \\W 匹配任意一个非数字、字母或下划线，即[^0-9a-zA-Z_]; 4. 量词 {n} 表示其前面的原子恰好出现n次; {n,} 表示其前面的原子最少出现n次; {n,m} 表示其前面的原子最少出现n次，最多出现m次; * 匹配0次、1次或者多次其之前的原子，即{0,}; + 匹配1次或者多次其之前的原子，即{1,}; ? 匹配0次或者1次其之前的原子，即{0,1}; 5. 边界控制 ^ 匹配字符串开始的位置; $ 匹配字符串结尾的位置; 6. 模式单元 () 匹配其中的整体为一个原子; 二、模式修正：1.懒惰匹配与贪婪匹配 (1) 贪婪匹配：匹配结果存在歧义时取其长(默认为贪婪模式) (2) 懒惰匹配：匹配结果存在歧义时取其短（懒惰模式标识：U 即：只需要在正则表达式的末尾加上U 如：/so.+234/U） 2.常见修正模式 U 懒惰匹配; i 忽略英文字母大小写; x 忽略空白; s 让元字符'.'匹配包括换行符在内的所有字符; e 配合函数preg_replace()使用,可以把匹配来的字符串当作正则表达式执行; 三、PHP中常用的正则表达式函数：1. preg_match()与preg_match_all() preg_match($pattern,$subject,[array &matches]) 第三个参数是传递引用，参数可选； preg_match()只会在$subject中匹配一次； return 匹配的次数（0次或1次） preg_match_all($pattern,$subject,array &matches) 第三个参数是传递引用，参数必填； preg_match_all()会把$subject中所有符合的匹配出来； return 匹配的次数（0次或多次） 2. preg_replace()与preg_filter() preg_replace($pattern,$replacement,$subject) return 返回被替换后的结果，（当为数组集时：不管替换部分和没有替换部分都会返回）； preg_filter($pattern,$replacement,$subject) return 返回替换后的结果，（当为数组集时：只保留被替换过的，没有替换的部分不返回；） 3. preg_grep() preg_grep($pattern,array $input) return 只返回被匹配到的结果集，没有匹配到的就过滤掉不返回 4. preg_split() preg_split($pattern,$subject) return 用匹配到的结果去截取字符串，将截取后的结果返回； 5. preg_quote() preg_quote($str) 正则运算符转义，如： ．＼＋＊？［＾］＄（）｛｝＝！＜＞｜：－","categories":[{"name":"笔记","slug":"笔记","permalink":"http://tiandawu.github.io/categories/笔记/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://tiandawu.github.io/tags/学习笔记/"}]},{"title":"怎么解决Android studio导入项目卡死","slug":"Android studio常见错误","date":"2016-01-16T09:29:24.000Z","updated":"2016-07-11T04:26:05.065Z","comments":true,"path":"2016/01/16/Android studio常见错误/","link":"","permalink":"http://tiandawu.github.io/2016/01/16/Android studio常见错误/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用Android studio的时候常常遇到这样的问题，从github或是其他地方导入项目，Android studio呈现卡死的现象！当遇到这种情况时，可以看看是下面那种情况，在按照方法来解决！","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用Android studio的时候常常遇到这样的问题，从github或是其他地方导入项目，Android studio呈现卡死的现象！当遇到这种情况时，可以看看是下面那种情况，在按照方法来解决！ 一、首次启动studio卡死当我们安装完studio，首次启动时如果卡死在这个画面： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时，我们只要到android studio的安装目录的bin目录下去找这个文件：idea.properties 文件，在文件的最后追加这样一句话即可：disable.android.first.run=true另一种方法时翻墙让它自己去慢慢下载！ 二、导入其他地方的项目卡死（很慢）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从github或其他地方导入项目如果studio很久也是像卡死的状态，这时你可以先将进程杀死，沿着这个路径：项目/gradle/wrapper找到这个文件： gradle-wrapper.properties ，将它打开看看这里： 一种方法是，去这个网站（Gradle Distributions）下好对应的版本。或者去gradle官网（需要翻墙，下载还很慢）下载也可以！然后将下载好的这个文件（gradle-2.10-all.zip）拷贝到这个目录下： C:\\Users\\Administrator\\.gradle\\wrapper\\dists \\gradle-2.10-all\\a4w5fzrkeut1ox71xslb49gst 注：a4w5fzrkeut1ox71xslb49gst这个文件夹名是随机数所以很可能不是一样的，然后再导入项目！ 另一种方法是，将上面那个文件的版本改成你自己那个目录有的版本，然后再导入项目。 三、studio升级后，新建项目卡死&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天在将studio 升级到最新版本后，新建了个醒目结果一直卡在这个界面： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我发现它又是去给我下载：gradle-2.10-all.zip去了，于是我按照上面的第二种方法修改了gradle的版本，然后再导入编译，结果又出现下面的问题： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后我就知道是gradle的版本高了，于是就到：项目的根目录找到build.gradle这个文件，做如下图的修改： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改后我又编译了一次，结果又冒出这样一个错误，如图： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是我又找到我又打开app目录下的build.gradle打开发现:compileSdkVersion &#39;Google Apis:Google Apis:23&#39;,最后将他做了如下图的修改： 这样项目才算是编译通过，能部署到手机上！ 最后我又按照上面的前一种方法做了一遍，发现一次性解决问题，什么文件也不用修改！ 四、最后总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不管是导入项目还是新建项目卡死，发现它是去下载：gradle-xxx-all.zip的时候最好的解决方案就是按照上面的方法自己去下载对应的版本，然后放到那个目录下，这样做省去了修改这，修改那的麻烦！","categories":[],"tags":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"http://tiandawu.github.io/tags/踩过的坑/"}]},{"title":"QQ抢红包插件实现","slug":"QQ红包插件实现","date":"2016-01-15T02:43:11.000Z","updated":"2016-07-11T04:23:34.752Z","comments":true,"path":"2016/01/15/QQ红包插件实现/","link":"","permalink":"http://tiandawu.github.io/2016/01/15/QQ红包插件实现/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前跟那些20年的单身狗抢红包是屡战屡败。再加上最近群里面发红包发的厉害，又想到快要过年了，到时候还不知道群里要发好多红包，所以我将之前在网上宕的一份微信抢红包的代码修改了一下，实现了QQ抢红包！可以支持抢QQ拼手气红包，普通红包，口令红包，现在再也不怕20年单身手速的人跟我抢红包了！","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前跟那些20年的单身狗抢红包是屡战屡败。再加上最近群里面发红包发的厉害，又想到快要过年了，到时候还不知道群里要发好多红包，所以我将之前在网上宕的一份微信抢红包的代码修改了一下，实现了QQ抢红包！可以支持抢QQ拼手气红包，普通红包，口令红包，现在再也不怕20年单身手速的人跟我抢红包了！ 先看测试效果图：1. 抢QQ口令红包： 可以看见，只要红包一发出，自动填写口令并发出，帮你将红包抢到手！ 2. 抢QQ拼手气红包： 拼手气红包也是一样，只要红包一发出，自动帮你把红包抢到手，是不是很爽的感觉？ 3. 抢QQ好友发送的红包： 只要好友或者群里的人把红包一发出，就会第一时间让你抢到红包！所以只要在群里面开启插件，抢红包从来都是百发百中！ 本插件主要是通过`AccessibilityService``来实现对屏幕的监控，从而实现抢红包的功能。代码比较少，下面从贴出源码来分析： MainActivity: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*MainActivity中的代码基本没改变：*/public class MainActivity extends AppCompatActivity &#123; private final Intent mAccessibleIntent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS); private Button switchPlugin; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); switchPlugin = (Button) findViewById(R.id.button_accessible); updateServiceStatus(); &#125; public void onButtonClicked(View view) &#123; startActivity(mAccessibleIntent); &#125; @Override protected void onResume() &#123; super.onResume(); updateServiceStatus(); &#125; private void updateServiceStatus() &#123; boolean serviceEnabled = false; AccessibilityManager accessibilityManager = (AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE); List&lt;AccessibilityServiceInfo&gt; accessibilityServices = accessibilityManager.getEnabledAccessibilityServiceList(AccessibilityServiceInfo.FEEDBACK_GENERIC); for (AccessibilityServiceInfo info : accessibilityServices) &#123; if (info.getId().equals(getPackageName() + \"/.QQHongbaoService\")) &#123; serviceEnabled = true; break; &#125; &#125; if (serviceEnabled) &#123; switchPlugin.setText(\"关闭插件\"); // Prevent screen from dimming getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; else &#123; switchPlugin.setText(\"开启插件\"); getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125;&#125; 这里是MainActivity中的全部代码，是不是很少的样子，主要是实现了一个按钮去开启ACCESSIBILITY_SERVICE。这个插件主要就是借助AccessibilityService这个服务来实现。所以剩下的核心功能代码就都在这个服务中了！ QQHongbaoService： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public class QQHongbaoService extends AccessibilityService &#123; private static final String WECHAT_OPEN_EN = \"Open\"; private static final String WECHAT_OPENED_EN = \"You've opened\"; private final static String QQ_DEFAULT_CLICK_OPEN = \"点击拆开\"; private final static String QQ_HONG_BAO_PASSWORD = \"口令红包\"; private final static String QQ_CLICK_TO_PASTE_PASSWORD = \"点击输入口令\"; private boolean mLuckyMoneyReceived; private String lastFetchedHongbaoId = null; private long lastFetchedTime = 0; private static final int MAX_CACHE_TOLERANCE = 5000; private AccessibilityNodeInfo rootNodeInfo; private List&lt;AccessibilityNodeInfo&gt; mReceiveNode; @TargetApi(Build.VERSION_CODES.KITKAT) public void recycle(AccessibilityNodeInfo info) &#123; if (info.getChildCount() == 0) &#123; if (info.getText() != null &amp;&amp; info.getText().toString().equals(QQ_CLICK_TO_PASTE_PASSWORD)) &#123; info.getParent().performAction(AccessibilityNodeInfo.ACTION_CLICK); &#125; if (info.getClassName().toString().equals(\"android.widget.Button\") &amp;&amp; info.getText().toString().equals(\"发送\")) &#123; info.performAction(AccessibilityNodeInfo.ACTION_CLICK); &#125; &#125; else &#123; for (int i = 0; i &lt; info.getChildCount(); i++) &#123; if (info.getChild(i) != null) &#123; recycle(info.getChild(i)); &#125; &#125; &#125; &#125; @TargetApi(Build.VERSION_CODES.JELLY_BEAN) @Override public void onAccessibilityEvent(AccessibilityEvent event) &#123; this.rootNodeInfo = event.getSource(); if (rootNodeInfo == null) &#123; return; &#125; mReceiveNode = null; checkNodeInfo(); /* 如果已经接收到红包并且还没有戳开 */ if (mLuckyMoneyReceived &amp;&amp; (mReceiveNode != null)) &#123; int size = mReceiveNode.size(); if (size &gt; 0) &#123; String id = getHongbaoText(mReceiveNode.get(size - 1)); long now = System.currentTimeMillis(); if (this.shouldReturn(id, now - lastFetchedTime)) return; lastFetchedHongbaoId = id; lastFetchedTime = now; AccessibilityNodeInfo cellNode = mReceiveNode.get(size - 1); if (cellNode.getText().toString().equals(\"口令红包已拆开\")) &#123; return; &#125; cellNode.getParent().performAction(AccessibilityNodeInfo.ACTION_CLICK); if (cellNode.getText().toString().equals(QQ_HONG_BAO_PASSWORD)) &#123; AccessibilityNodeInfo rowNode = getRootInActiveWindow(); if (rowNode == null) &#123; Log.e(TAG, \"noteInfo is null\"); return; &#125; else &#123; recycle(rowNode); &#125; &#125; mLuckyMoneyReceived = false; &#125; &#125; &#125; /** * 检查节点信息 */ private void checkNodeInfo() &#123; if (rootNodeInfo == null) &#123; return; &#125; /* 聊天会话窗口，遍历节点匹配“点击拆开”，“口令红包”，“点击输入口令” */ List&lt;AccessibilityNodeInfo&gt; nodes1 = this.findAccessibilityNodeInfosByTexts(this.rootNodeInfo, new String[]&#123; QQ_DEFAULT_CLICK_OPEN, QQ_HONG_BAO_PASSWORD, QQ_CLICK_TO_PASTE_PASSWORD, \"发送\"&#125;); if (!nodes1.isEmpty()) &#123; String nodeId = Integer.toHexString(System.identityHashCode(this.rootNodeInfo)); if (!nodeId.equals(lastFetchedHongbaoId)) &#123; mLuckyMoneyReceived = true; mReceiveNode = nodes1; &#125; return; &#125; &#125; /** * 将节点对象的id和红包上的内容合并 * 用于表示一个唯一的红包 * * @param node 任意对象 * @return 红包标识字符串 */ private String getHongbaoText(AccessibilityNodeInfo node) &#123; /* 获取红包上的文本 */ String content; try &#123; AccessibilityNodeInfo i = node.getParent().getChild(0); content = i.getText().toString(); &#125; catch (NullPointerException npe) &#123; return null; &#125; return content; &#125; /** * 判断是否返回,减少点击次数 * 现在的策略是当红包文本和缓存不一致时,戳 * 文本一致且间隔大于MAX_CACHE_TOLERANCE时,戳 * * @param id 红包id * @param duration 红包到达与缓存的间隔 * @return 是否应该返回 */ private boolean shouldReturn(String id, long duration) &#123; // ID为空 if (id == null) return true; // 名称和缓存不一致 if (duration &lt; MAX_CACHE_TOLERANCE &amp;&amp; id.equals(lastFetchedHongbaoId)) &#123; return true; &#125; return false; &#125; /** * 批量化执行AccessibilityNodeInfo.findAccessibilityNodeInfosByText(text). * 由于这个操作影响性能,将所有需要匹配的文字一起处理,尽早返回 * * @param nodeInfo 窗口根节点 * @param texts 需要匹配的字符串们 * @return 匹配到的节点数组 */ private List&lt;AccessibilityNodeInfo&gt; findAccessibilityNodeInfosByTexts(AccessibilityNodeInfo nodeInfo, String[] texts) &#123; for (String text : texts) &#123; if (text == null) continue; List&lt;AccessibilityNodeInfo&gt; nodes = nodeInfo.findAccessibilityNodeInfosByText(text); if (!nodes.isEmpty()) &#123; if (text.equals(WECHAT_OPEN_EN) &amp;&amp; !nodeInfo.findAccessibilityNodeInfosByText(WECHAT_OPENED_EN).isEmpty()) &#123; continue; &#125; return nodes; &#125; &#125; return new ArrayList&lt;&gt;(); &#125; @Override public void onInterrupt() &#123; &#125;&#125; QQHongbaoService的全部代码也在这里，代码也不多。首先，在这个服务中主要是通过findAccessibilityNodeInfosByText这个方法去获我们需要的节点；然后，用 performAction(AccessibilityNodeInfo.ACTION_CLICK) 这个方法去点击红包节点，关键思路大概就是这样！另外如果是口令红包，我们需要先按照上面的步骤将红包戳开，然后通过performAction(AccessibilityNodeInfo.ACTION_CLICK)去点击输入口令，最后再通过点击去发送即可实现！ QQHongbaoService需要在AndroidManifest.xml文件中注册，注册的节点如下图： 总体来看，只是将微信抢红包的代码做了少量的修改，在这里要感谢微信抢红包源码的贡献！最后也希望这篇文章能给大家有所帮助，在抢红包大战中百战百胜！ 下面是源码地址：点击：下载地址","categories":[{"name":"Android","slug":"Android","permalink":"http://tiandawu.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://tiandawu.github.io/tags/Android/"}]},{"title":"Hexo+github搭建个人博客","slug":"BuildMyBlog","date":"2016-01-14T02:43:11.000Z","updated":"2016-07-10T13:01:52.947Z","comments":true,"path":"2016/01/14/BuildMyBlog/","link":"","permalink":"http://tiandawu.github.io/2016/01/14/BuildMyBlog/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章主要讲解怎么利用Hexo和github来搭建自己的博客！如果你正想搭建一个属于自己的博客，那么就不妨动手跟我一起来搭建 ！","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章主要讲解怎么利用Hexo和github来搭建自己的博客！如果你正想搭建一个属于自己的博客，那么就不妨动手跟我一起来搭建 ！ 一.环境搭建&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在搭建之前我们首先要搭建环境，首先要做的是安装Git和Node.js(最好翻墙后打开)，先去这两个网站官网下载并安装好，安装的过程很简单，就是一路下一步即可！其次要做的是打开你的git Bash窗口，输入如下命令：1$ npm install -g hexo-cli 完成以上操作后，你就算将Hexo也安装好了，安装Hexo也可以参看Hexo的官网。至此，环境搭建已经完成！ 二.创建本地博客&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本地磁盘新建一个文件夹，我这里命名为：MyBlog，然后鼠标右击该文件夹，打开：Git Bash Here。在弹出的命令窗口中输入以下命令:1$ hexo init yourname.github.io 需要注意的是：这里需要将命令中的yourname替换成你的github的账户名，必须要是和账户名一致！执行完这条命令后就会在你刚才新建的文件夹下生成一个名字为：yourname.github.io的文件夹。然后，又执行如下几条命令：1234$ cd yourname.github.io //cd到刚才自动创建的目录下$ npm install$ hexo g$ hexo s 执行完以上命令后，不要关闭Git Bash窗口，用浏览器打开：http://localhost:4000/ 你就会看见自己的本地博客页面了，如图： 三.将本地博客部署到github上1. 在github上创建一个仓库按照下图创建：填写完成，点解Create repository完成创建即可！ 2. 将刚创建的远程仓库更新下来步骤如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依然是鼠标右击：yourname.github.io打开Git Bash Here,执行如下命令：1234$ git init //初始化git仓库$ git remote add origin git@github.com:yourname/yourname.github.io.git //将yourname替换//给远程仓库添加一个名为：origin 的引用$ git fetch origin //获取远程仓库的内容$ git merge origin/master //将获取的内容合并到master分支 3. 修改配置文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着用sublime或者notepad++打开：yourname.github.io文件夹下的这个文件：_config.yml，在文件最后做如下修改：1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 以下两步是有自己域名的看：如果你有自己的域名，可以将上面修改如下：12345deploy: type: git repo: git@github.com:tiandawu/tiandawu.github.io.git branch: master plugins: -hexo-generator-cname 另外还需要修改的是这里：1234url: http://tiandawu.com //这里改成自己的域名root: /permalink: :year/:month/:day/:title/permalink_defaults: 好了，至此配置文件修改完毕。 4. 部署到github&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依然来到刚才的Git Bash窗口，执行如下命令：有自己域名的需要先执行这条命令：1$ npm install hexo-generator-cname --save //这条命令执行过程较慢，耐心等待！(需要翻墙快) 下面的命令都需要执行：123$ git add .$ git commit -m \"输入自己的描述信息\"$ git push origin master 执行完上面的命令，没有配置自己域名的再执行下面两条命令就可访问自己的博客了：(在浏览器中输入：yourname.github.io访问)12$ hexo g$ hexo d 注意：在执行：$ hexo d的时候如果出现下面的错误：这时候只需要先执行这条命令:1$ npm install hexo-deployer-git --save 然后后再执行下面这条部署命令就行了！1$ hexo d 配置了自己域名的还需要执行完下面的命令：12$ git fetch origin$ git merge origin/master 配置了自己域名的还需要修改CNAME文件，public文件夹下的CNAME也要修改，都填写上自己的域名即可！可以参考我填写的CNAME文件。配置了自己域名的最后执行下面命令也能访问了：（可以通过：yourname.github.io或你的域名访问）12345$ git add .$ git commit -m \"输入自己的描述信息\"$ git push origin master$ hexo g$ hexo d 不管你有没有自己的域名，现在如果你能通过以上两种方式看到这个页面就算你搭建成功了（恭喜！）： 四.配置Next主题Hexo提供了很多的主题，可以参考丰富多彩的Hexo主题，这里我选用的是配置Next主题，我的博客样式。具体配置详情，请参考：Next主题官方文档。 五.搭建遇到的坑我在将主题设置成Next后，在将仓库向github提交了一遍，结果就收到一封这样的邮件： 于是我就点了链接，看到给的解决方案是这样的： 于是我就按照这个方法做，结果出现下面的错误： 经过几番尝试，我将之前更新下来的主题全删掉，然后输入下面的命令去下载主题： git submodule add https://github.com/iissnan/hexo-theme-next如图： 这样更新下主题后，发现在：yourname.github.io文件夹下会多出一个.gitmodules的文件，然后我在按照之前的方法尝试，结果就不出现那个错误，将文件push到远程仓库也不会收到刚才那邮件了，这个坑就这样被填上了！","categories":[],"tags":[]}]}